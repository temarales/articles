\documentclass[11pt, oneside, a4paper]{article}
%\usepackage[cp1251]{inputenc} % кодировка
\usepackage[utf8]{inputenc} % кодировка
\usepackage[english, russian]{babel} % Русские и английские переносы
\usepackage{graphicx}          % для включения графических изображений
\usepackage{cite}              % для корректного оформления литературы
\usepackage{enumitem}
\usepackage{pavt-ru}  
\usepackage{amsmath}                              

\begin{document}

% \title - название статьи
% \authors - список авторов

\title{Поиск оптимального алгоритма сжатия сигнала\\на системах с общей памятью}

\authors{А.В.~Данилова\superscript{1}, Н.В.~Пауков\superscript{1}, М.А.~Теплякова\superscript{1}}
\organizations{\superscript{1}Воронежский государственный университет}

% Аннотация заключается в окружение abstract
\begin{abstract}
Аннотация содержит краткое описание статьи и не должна превышать
10~строк. Она оформляется шрифтом размером 10~пт с отступом 15~мм слева
и справа, выравниванием по ширине. Сверху и снизу аннотация отделяется
от остального текста интервалом в 1 строку размером 16~пт. Настоящий
текст оформлен в соответствии со всеми требованиями и может быть
использован в качестве шаблона.
\end{abstract}

\keywords{дискретное косинусное преобразование Фурье, сжатие сигналов, параллельное программирование}

% \section{название} - заголовок раздела первого уровня
% \subsection{название} - заголовок раздела второго уровня
% \subsubsection{название} - заголовок раздела третьего уровня
% Не используйте уровень вложенности заголовков больше трех!
% Каждый абзац текста в статье начинается командой \par или пустой
% строкой.

\section{Введение}

Обработка цифровых сигналов, несомненно, является перспективной и крайне важной областью научных исследований. Обработка сигнала позволяет избавиться от постороннего шума, появляющегося в результате неточных измерений, фоновых помех или неисправности аппаратуры, и тем самым получить только полезную информацию из сигнала. Кроме того, обработка сигнала может использоваться для сжатия сигналов, что также важно на практике, так как это позволяет сохранить всю важную информацию, присутствующую в сигнале, сократив при этом объём памяти, используемый для её хранения. 

Многие алгоритмы сжатия основаны на использовании дискретного косинусного преобразования Фурье(\ref{DCT}). Для широкого спектра сигналов вышеуказанное преобразование является эффективным. Также данное преобразование активно используется и в реализации многих алгоритмов сжатия изображения и видео, таких как JPEG, MPEG и прочих.
\begin{equation}
\label{DCT}
\hat{f_k}=\frac{1}{\sqrt{2n+1}}(f_0+2\sum\limits_{m=1}^{n}f_m\cos(\frac{2 \pi k m}{2n+1}))
\end{equation}
Матричный вид косинусного преобразования Фурье:
$$\frac{1}{\sqrt{2n+1}}\begin{pmatrix}
1 & 2 & 2 & \ldots & 2\\
1 & 2\cos\frac{2 \pi}{2n+1} & 2\cos\frac{2 \pi 2}{2n+1} & \ldots & 2\cos\frac{2 \pi n}{2n+1}\\
\vdots & \vdots & \ddots & \vdots\\
1 & 2\cos\frac{2 \pi 2}{2n+1} & 2\cos\frac{2 \pi 4}{2n+1} & \ldots & 2\cos\frac{2 \pi 2n}{2n+1}
\end{pmatrix}$$

Но существенным аспектом алгоритмов сжатия сигналов является тот факт, что для каждого типа сигнала оптимальным является лишь свой конкретный метод сжатия. Следовательно, вопрос автоматического отыскания оптимального метода сжатия для конкретного типа сигнала представляет серьёзный практический интерес. Таким образом, целью данного исследования было выбрано создание подобного метода. При наличии значительных вычислительных ресурсов, данную задачу можно было бы решить простым перебором различных матриц преобразования, но в реальных условиях это заняло бы слишком большое количество времени. Помимо того, немаловажно чётко определить то, какие матрицы будут считаться оптимальными. Таким образом, основными задачами данного исследования были определены следующие:
\begin{itemize}
\item Создание эффективного алгоритма для поиска оптимальных матриц преобразования
\item Выбор критерия для определения оптимальности матрицы преобразования
\end{itemize}
	
Так как поиск оптимальных матриц является ресурсозатратной задачей, то для её реализации было принято решение использовать алгоритмы параллельного программирования для систем с общей памятью. В качестве наиболее доступного программного обеспечения была взята распространённая реализация стандарта MP - OpenMP. Все вычисления были проведены с использованием ресурсов Воронежского суперкомпьютерного центра.

\section{Методика}

При решении вышеозначенной задачи сжатие сигналов осуществляется следующим образом. Берётся сигнал, представленный в векторном виде, и матрица преобразования соответствующего размера. Матрица преобразования проверяется на вырожденность, путём рассчёта её определителя. В случае, если её определитель равен нулю, дальнейшие действия не производятся и берётся другая матрица преобразования. Если же определитель отличен от нуля, то матрица $S$ умножается на сигнал $X$(\ref{multiply}).
\begin{equation}
\label{multiply}
Y = S * X
\end{equation}

Далее проводится фильтрация полученного преобразованного сигнала $Y$ и, в зависимости от желаемой степени сжатия, фиксированная часть значений в сигнале, являющихся наименьшими по модулю, зануляется. Тем самым отбрасывается избыточная информация. Полученный после проведения фильтрации сигнал обозначается $\tilde{Y}$. После этого производится обратное преобразования сигнала $\tilde{Y}$, путём его умножения на матрицу $S^{-1}$, обратную к первоначально взятой матрице преобразования $S$(\ref{inverse}).
\begin{equation}
\label{inverse}
\tilde{X} = S^{-1} * \tilde{Y}
\end{equation}

Для определения степени сжатия вычисляется ошибка между исходным и полученным сигналом(\ref{delta}). Оптимальной будет считаться матрица преобразования, имеющуая среднюю ошибку меньшую, чем дискретное косинусное преобразование Фурье, или же близкую к нему.
\begin{equation}
\label{delta}
\delta = \frac{||X - \tilde{X}||^2}{n}
\end{equation}

\section{Алгоритм}

\subsection{Генерация сигналов}
Для решения поставленной задачи исследование проводится на наборе из 20~сигналов. Поиск оптимального алгоритма сжатия имеет большую вычислительную сложность. В связи с этим для уменьшения количества операций рассматриваются сигналы, состоящие из 8~точек. В исследовании используются сигналы, которые представляют собой набор точек из QRS-комплекса ЭКГ.

\subsection{Генерация матриц преобразования}

В рамках исследования в качестве элементов матрицы преобразования \textit {T} берутся числа 1, 0 и -1. Для выбора оптимальной матрицы следует рассмотреть все матрицы \textit {T}, которые можно составить из выбранных элементов. Однако решение данной задачи для сигналов, состоящих из незначительного числа точек, требует большого количества вычислительных ресурсов. Для уменьшения объема вычислений предлагается проводить классификацию генерируемых матриц. 

\subsubsection{Первый этап}

На начальном этапе матрицы выделяются в класс по количеству входящих в их состав элементов. Обозначим $I_0$ – класс матриц, в которых не встречается число 1, $I_1$ - класс матриц, в которых число 1 встречается один раз. Поскольку рассматриваются сигналы длиной 8 точек, последним классом будет $I_{64}$, в который входит матрица, состоящая только из единиц. Далее для каждого из выделенных классов необходимо сгенерировать несколько соответствующих им матриц, провести преобразование сигналов и на основании полученных результатов выявить наиболее эффективный из классов.

Следующим действием класс матриц, который оказался наиболее оптимальным, необходимо разделить на подклассы по количеству числа -1. Пусть {\it n} – число единиц в рассматриваемых матрицах, тогда новые классы разбиения обозначим как $NI_0^n$, $NI_1^n$, \ldots, $NI^n_{64}$. Далее также генерируются несколько матриц для каждого класса, и проводится исследование, в результате которого будет определено оптимальное количество числа -1 (обозначим его {\it m}). Таким образом, на данном этапе будет выделен класс матриц $NI_m^n$, который наилучшим образом подходит для решения поставленной задачи. Для найденного класса известен точный состав матриц: количество числа 1 равно {\it n}, количество числа -1 составляет {\it m}, количество числа 0 обозначим {\it k}, которое определяется по формуле~(\ref{k}).

\begin{equation}
\label{k}
k=64-n-m
\end{equation}


\subsubsection{Второй этап}

На данном этапе матрицы классифицируются с точки зрения распределения элементов по строкам. Пусть исследование начинается с числа~1. Рассматривается первая строка. Обозначим $R^1_0$ – класс матриц, в первой строке которых число~1 не встречается, $R^1_1$ – класс матриц, в первой строке которых число~1 встречается один раз. Последним классом будет $R^2_8$, ему соответствуют матрицы, первая строка которых состоит только из единиц. Для каждого класса генерируется несколько матриц таким образом, чтобы в первой строке было соответствующее рассматриваемому классу количество элементов, равных~1, а в остальных строках они были случайно распределены. Затем выделяется тот класс, который наиболее оптимально решает поставленную задачу. Далее рассматривается следующая строка, и для нее аналогично выделяются классы $R^2_0$, $R^2_1$, \ldots, $R^2_8$. При генерации матриц первая строка заполняется согласно требованиям класса, который был выбран на предыдущем шаге, вторая строка должна соответствовать текущему классу, остальные заполняются случайным образом, при этом общее количество числа~1 должно быть равно {\it n}. Такая классификация проводится для всех строк матрицы. 

Затем проводится классификация по распределению числа~-1 по аналогии с тем, как проводилось для 1. В результате для всех строк матрицы будет известно количество каждого элемента, которые ее составляют (обозначим $n_i$, $m_i$, $k_i$ для 1, -1, 0 соответственно, где {\it i} = 1, 2, \ldots, 8 -- номера строк).

\subsubsection{Третий этап}

Это последний этап классификации, на котором матрицы разделяются по расположению элементов в строке. Рассматривается первая строка. С помощью перестановки элементов формируются различные комбинации их расположения в строке, каждый из которых образует свой класс матриц. Среди них проводится поиск наилучшей. Аналогичные действия производятся для каждой строки.

В результате третьего этапа классификации будет известен точный вид матрицы, наилучшим образом решающей поставленную задачу.

\end{document}